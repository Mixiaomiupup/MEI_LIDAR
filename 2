//雷达

#include <iostream>
#include <fstream>
#include <unistd.h>
#include <pthread.h>
#include <cmath>
// #include <thread>
#include <ros/ros.h> 
#include <chrono>
#include <unistd.h>
#include <pthread.h>
#include <vector>
#include <sensor_msgs/LaserScan.h>

#include "serial.h"
#include "kalman.h"
// #include "test.h"

#include "pcl_conversions/pcl_conversions.h"
#include <pcl/visualization/pcl_visualizer.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/filters/passthrough.h>
#include <pcl/ModelCoefficients.h>
#include <pcl/point_types.h>
#include <pcl/sample_consensus/method_types.h>
#include <pcl/sample_consensus/model_types.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/io/pcd_io.h>
#include <pcl/features/normal_3d.h>
#include <fstream>
#include <pcl/filters/project_inliers.h>


#include <pcl/filters/radius_outlier_removal.h>
#include <pcl/filters/conditional_removal.h>
#include <pcl/filters/statistical_outlier_removal.h>

using namespace std;
using namespace std::literals::chrono_literals;
typedef pcl::PointXYZ PointT;
fstream f1("/home/mei18/catkin_ws/data0.txt",ios::out|ios::trunc);
class cylinder_Node{
public:
  double x;
  double y;
  cylinder_Node* left;
  cylinder_Node* right;
  cylinder_Node(){
    x=100000;
    y=100000;
    left=NULL;
    right=NULL;
  }
  cylinder_Node(double x1,double y1){
    x=x1;
    y=y1;
    left=NULL;
    right=NULL;
  }
};
class cylinder_tree{//二叉搜索树


  public:
    cylinder_Node* tree;
  cylinder_Node* trees[5];
  int index;
  cylinder_tree(){
    tree=new cylinder_Node();
    index=0;
  }
  void setTree(double x,double y){
    tree->x=x;
    tree->y=y;
  }
  cylinder_Node* insert(cylinder_Node* node,double x,double y){
    if(node==NULL){
      return new cylinder_Node(x,y);
    }
    if(x<node->x){
      node->left=insert(node->left,x,y);
      return node;
    }
    else if(x>node->x){
      node->right=insert(node->right,x,y);
      return node;
    }
    else{
     // cout<<"有重复"<<endl;
      return node;
    }
  }

  void preorder(cylinder_Node* node){//钱旭遍历给柱子编号
    if(node==NULL){
      return;
    }
    preorder(node->left);
    trees[index]=node;
    index++;
    preorder(node->right);
  }
  void get_coordinate(double& XS,double& YS,int count){
    preorder(tree);//排好序的柱子
    double sin,cos;
    double XR,YR;
    if(index==4||index==5){//四个是在进踢球区的边界三个中的第一个或第三个被挡住了
      if(trees[1]->y < trees[0]->y && trees[1]->y < trees[2]->y&& trees[3]->y <trees[0]->y && trees[3]->y < trees[2]->y ){//0 2号柱子
      sin=(trees[0]->y-trees[2]->y)/sqrt(pow(trees[0]->x-trees[2]->x,2)+pow(trees[0]->y-trees[2]->y,2));//雷达坐标系相对世界坐标系的旋转角度的三角函数
      cos=(trees[2]->x-trees[0]->x)/sqrt(pow(trees[0]->x-trees[2]->x,2)+pow(trees[0]->y-trees[2]->y,2));
      XR=3090;//世界坐标系中柱子的坐标
      YR=0;

      XS=XR-trees[0]->x*cos+trees[0]->y*sin;
      YS=YR-trees[0]->x*sin-trees[0]->y*cos;
      cout<<"xs: "<<XS<<" ys: "<<YS<<endl;
    
      }
      else if(trees[0]->y < trees[1]->y && trees[0]->y < trees[3]->y&& trees[2]->y <trees[1]->y && trees[2]->y < trees[3]->y ){//1 3号柱子
      sin=(trees[1]->y-trees[3]->y)/sqrt(pow(trees[1]->x-trees[3]->x,2)+pow(trees[1]->y-trees[3]->y,2));//雷达坐标系相对世界坐标系的旋转角度的三角函数
      cos=(trees[3]->x-trees[1]->x)/sqrt(pow(trees[1]->x-trees[3]->x,2)+pow(trees[1]->y-trees[3]->y,2));
      XR=5750;//世界坐标系中柱子的坐标
      YR=0;

     XS=XR-trees[1]->x*cos+trees[1]->y*sin;
     YS=YR-trees[1]->x*sin-trees[1]->y*cos;
      cout<<"xs: "<<XS<<" ys: "<<YS<<endl;
     
      }
     else{
        cout<<"xs: " <<0<<" ys: "<<0<<endl;
        
   }
  }
 else if(index==3){//3个柱子是在侧面时被挡了一个，导致这个和它前面或者后面的那个也不找了，只有三个

      if(count==2){//一个柱子在前面两个柱子在后面，向后了两次
      XR=3090;//世界坐标系中柱子的坐标
      YR=0;
      }
      if(count==3){//两个柱子在前面一个柱子在后面，向后了一次
      XR=5750;//世界坐标系中柱子的坐标
      YR=0;
      }
      sin=(trees[0]->y-trees[2]->y)/sqrt(pow(trees[0]->x-trees[2]->x,2)+pow(trees[0]->y-trees[2]->y,2));//雷达坐标系相对世界坐标系的旋转角度的三角函数
      cos=(trees[2]->x-trees[0]->x)/sqrt(pow(trees[0]->x-trees[2]->x,2)+pow(trees[0]->y-trees[2]->y,2));

      XS=XR-trees[0]->x*cos+trees[0]->y*sin;
      YS=YR-trees[0]->x*sin-trees[0]->y*cos;
      cout<<"xs: "<<XS<<" ys: "<<YS<<endl;
    
    }
  else{//其他时候都不符合要求
    XS=0;
    YS=0;
    cout<<"xs: "<<XS<<" ys: "<<YS<<endl;
  }

}
};
double distance(double a1,double b1,double a2,double b2){
  return sqrt(pow(a1-b1,2) + pow(a2-b2,2));
}
//切割点云
pcl::PointCloud<PointT>::Ptr partition(pcl::PointCloud<PointT>::Ptr clouds,double x0,double x1,double y0,double y1,double z0,double z1){
    pcl::PointCloud<PointT>::Ptr cloud0 (new pcl::PointCloud<PointT>);
    pcl::PointCloud<PointT>::Ptr cloud1 (new pcl::PointCloud<PointT>);
    pcl::PointCloud<PointT>::Ptr cloud2 (new pcl::PointCloud<PointT>);
    pcl::PassThrough<PointT> pass;
    pass.setInputCloud (clouds);
    pass.setFilterFieldName ("x");
    pass.setFilterLimits (x0,x1);
    pass.filter (*cloud0);

    pass.setInputCloud (cloud0);
    pass.setFilterFieldName ("y");
    pass.setFilterLimits (y0,y1);
    pass.filter (*cloud1);

    pass.setInputCloud (cloud1);
    pass.setFilterFieldName ("z");
    pass.setFilterLimits (z0,z1);
    pass.filter (*cloud2);
    return cloud2;

}

  
void velodyneViewerCallback(const sensor_msgs::PointCloud2::ConstPtr &lidarMsg) {
  int i=0;
  int j=0;
	// All the objects needed
  pcl::PCDReader reader;
  //pcl::PassThrough<PointT> pass;
  pcl::NormalEstimation<PointT, pcl::Normal> ne;
//  pcl::SACSegmentationFromNormals<PointT, pcl::Normal> seg; 
  pcl::PCDWriter writer;

  //pcl::ExtractIndices<PointT> extract;
  //pcl::ExtractIndices<pcl::Normal> extract_normals;
  pcl::search::KdTree<PointT>::Ptr tree (new pcl::search::KdTree<PointT> ());

  // Datasets
  pcl::PointCloud<PointT>::Ptr cloud (new pcl::PointCloud<PointT>);




   pcl::PointCloud<PointT>::Ptr cloud_cylinder0 (new pcl::PointCloud<PointT> ());
  pcl::PointCloud<PointT>::Ptr cloud_cylinder1 (new pcl::PointCloud<PointT> ());
  pcl::PointCloud<PointT>::Ptr cloud_cylinder2 (new pcl::PointCloud<PointT> ());
    pcl::PointCloud<PointT>::Ptr cloud_cylinder3 (new pcl::PointCloud<PointT> ());
  pcl::PointCloud<PointT>::Ptr cloud_cylinder4 (new pcl::PointCloud<PointT> ());
  vector<pcl::PointCloud<PointT>::Ptr> cloud_cylinders;
  cloud_cylinders.push_back(cloud_cylinder0);
  cloud_cylinders.push_back(cloud_cylinder1);
  cloud_cylinders.push_back(cloud_cylinder2);
  cloud_cylinders.push_back(cloud_cylinder3);
  cloud_cylinders.push_back(cloud_cylinder4);


 fromROSMsg(*lidarMsg,*cloud);

i=0;
j=1;
double xl=0;
double xr=1.4;
double yl=-4.5;//放宽的话歪了也能看见
double yr=0;
double zl=-0.1;
double zr=1.5;
double Rxl,Rxr;//第一个柱子后面的开始坐标
  pcl::ModelCoefficients::Ptr coefficients_cylinder (new pcl::ModelCoefficients);
  pcl::PointIndices::Ptr  inliers_cylinder (new pcl::PointIndices);
  pcl::PointCloud<pcl::Normal>::Ptr cloud_normals (new pcl::PointCloud<pcl::Normal>);
  pcl::SACSegmentationFromNormals<PointT, pcl::Normal> seg; 
  pcl::ExtractIndices<PointT> extract;
  pcl::ExtractIndices<pcl::Normal> extract_normals;
   
  pcl::PointCloud<PointT>::Ptr cloud_filtered (new pcl::PointCloud<PointT>);
  pcl::PointCloud<PointT>::Ptr cloud_cylinder (new pcl::PointCloud<PointT> ());
  double sum_x[5]={0,0,0,0,0};
  double sum_y[5]={0,0,0,0,0};
  double x[5]={0,0,0,0,0};
  double y[5]={0,0,0,0,0};
  double X0,Y0;//第一次拟合的圆柱的坐标
  double X1,Y1;//第二次拟合的圆柱的坐标
  int count=0;//计算向后找了几次
cylinder_tree* cylinders=new cylinder_tree();

 while(i<5){

  cout<<"开始"<<"x:"<<xl<<" "<<xr<<endl;

   cloud_filtered = partition(cloud,xl,xr,yl,yr,zl,zr);
   
  // cout<<"cloud_filtered: "<<cloud_filtered->points.size()<<endl;
   if(cloud_filtered->points.size()==0){//如果点云里没有就直接换方向
  //cout<<" 没有"<<endl;
  if(i==0){//如果一开始就没找到就朝着反方向找
  xl=-1.4;
  xr=0;
  }
  else{//朝着第一个柱子的反方向找
  xl=Rxl;
  xr=Rxr;
  }
 
  j=0;
  count++;
  cout<<"没找到"<<"x:"<<xl<<" "<<xr<<endl;
  if(count==4){//count最多等于三，在找到三个柱子且两个在前面一个在后面
    break;
  }
  //cout<<111<<endl;
  continue;
        
}

   ne.setSearchMethod (tree); //cout<<i<<" kazhu"<<endl;
 //cout<<count<<" count"<<endl;
   ne.setInputCloud (cloud_filtered);
   ne.setKSearch (50);
   ne.compute (*cloud_normals);
  
   seg.setOptimizeCoefficients (true);
   seg.setModelType (pcl::SACMODEL_CYLINDER);
   seg.setMethodType (pcl::SAC_RANSAC);
   seg.setNormalDistanceWeight (0.01);//越小对远处的圆柱拟合越好,0.05容易把一个柱子切两次
   seg.setMaxIterations (10000);
   seg.setDistanceThreshold (0.1);//0.1基本不需要动
   seg.setRadiusLimits (-0.06, 0.06);

   seg.setInputCloud (cloud_filtered);//去除第０到第i-1个圆柱的点云

   seg.setInputNormals (cloud_normals);//去除第０到第i-１个圆柱切线的切线集

   // Obtain the cylinder inliers and coefficients
   seg.segment (*inliers_cylinder, *coefficients_cylinder);
  // cout<<"1"<<endl;
   //std::cerr << "Cylinder1 coefficients: " << *coefficients_cylinder1 << std::endl;

  extract.setInputCloud (cloud_filtered);
  extract.setIndices (inliers_cylinder);
  extract.setNegative (false);
 
  extract.filter (*cloud_cylinder);
 // cout<<"cloud_cylinder: "<<cloud_cylinder->points.size()<<endl;
if(cloud_cylinder->points.size()==0){//把点云有点但是没有圆柱的情况排除
  //cout<<" 没有"<<endl;
  if(i==0){//如果一开始就没找到就朝着反方向找
  xl=-1.4;
  xr=0;
  }
  else{//朝着第一个柱子的反方向找
  xl=Rxl;
  xr=Rxr;
  }
 
  j=0;
  count++;
  cout<<"没找到"<<"x:"<<xl<<" "<<xr<<endl;
  if(count==4){//count最多等于三，在找到三个柱子且两个在前面一个在后面
    break;
  }
  // cout<<111<<endl;
  continue;
        
}
 

  for(int  it = 0;it < cloud_cylinder->points.size();++it){
	  	sum_x[i] += (double)cloud_cylinder->points[it].x*1000;
	  	sum_y[i] += (double)cloud_cylinder->points[it].y*1000;


   }

   x[i]= sum_x[i]/cloud_cylinder->points.size();
   y[i]=sum_y[i]/cloud_cylinder->points.size();
   X0=x[i];
   Y0=y[i];
   sum_x[i]=0;
   sum_y[i]=0;

   cloud_filtered = partition(cloud,X0/1000-0.2,X0/1000+0.2,Y0/1000-0.2,Y0/1000+0.2,zl,zr);
  // cout<<"cloud_filtered: "<<cloud_filtered->points.size()<<endl;
for(int  it = 0;it < cloud_filtered->points.size();++it){
	  	sum_x[i] += (double)cloud_filtered->points[it].x*1000;
	  	sum_y[i] += (double)cloud_filtered->points[it].y*1000;


   }

   x[i]= sum_x[i]/cloud_filtered->points.size();
   y[i]=sum_y[i]/cloud_filtered->points.size();
   X1=x[i];
   Y1=y[i];
  // cout<<X0<<" "<<X1<<" "<<Y0<<" "<<Y1<<endl;  
  if(distance(X0,X1,Y0,Y1)<50){//两次拟合的圆柱的距离小于50

   if(i==0){

      cylinders->setTree(X1,Y1);
   }
    else{
  
      cylinders->insert(cylinders->tree,X1,Y1);
   }

   *cloud_cylinders[i]=*cloud_filtered;//把找到的柱子存起来
    if(j){//j==1为朝正方向
    xl=X1/1000+0.5;
    xr=xl+1.4; 
    }
   else{//j==0为朝反方向
    xr=X1/1000-0.5;
    xl=xr-1.4;
   }
    if(i==0){//把第一个柱子的反方向的第一个柱子的界限设定好
      Rxr=X1/1000-0.5;
      Rxl= Rxr-1.4;
    }
    i++;//找下一个柱子
   // cout<<"找到了"<<X1<<" "<<Y1<<endl;
  }
  else{//如果第一次找的柱子和第二次扩充的点云中的东西的距离大于50，直接退出循环
   break;
  }
}
double XS,YS;
cout<<"i="<<i<<endl;
  cylinders->get_coordinate(XS,YS,count);



f1<<XS<<" "<<YS<<endl;
//cylinders->get_coordinate(XS,YS,count);




   boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer0 (new pcl::visualization::PCLVisualizer ("3D Viewer0"));
 boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer1 (new pcl::visualization::PCLVisualizer ("3D Viewer1"));
 boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer2 (new pcl::visualization::PCLVisualizer ("3D Viewer2"));
   boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer3 (new pcl::visualization::PCLVisualizer ("3D Viewer3"));
  boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer4 (new pcl::visualization::PCLVisualizer ("3D Viewer4"));
  boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer5 (new pcl::visualization::PCLVisualizer ("3D Viewer5"));
    boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer6 (new pcl::visualization::PCLVisualizer ("3D Viewer6"));

  viewer0->addPointCloud<pcl::PointXYZ> (cloud, "sample cloud0");
  viewer1->addPointCloud<pcl::PointXYZ> (partition(cloud,-4,6,yl,yr,zl,zr), "sample cloud1");
  viewer2->addPointCloud<pcl::PointXYZ> (cloud_cylinders[0], "sample cloud2");
  viewer3->addPointCloud<pcl::PointXYZ> (cloud_cylinders[1], "sample cloud3");
  viewer4->addPointCloud<pcl::PointXYZ> (cloud_cylinders[2], "sample cloud4");
  viewer5->addPointCloud<pcl::PointXYZ> (cloud_cylinders[3], "sample cloud5");
  viewer6->addPointCloud<pcl::PointXYZ> (cloud_cylinders[4], "sample cloud6");
  //查看法线
  // viewer0->addPointCloudNormals<pcl::PointXYZ, pcl::Normal> (cloud2,cloud_normals0, 10, 0.2, "normals0");
  // viewer1->addPointCloudNormals<pcl::PointXYZ, pcl::Normal> (cloud_cylinder0,cloud_normals1, 10, 0.2, "normals1");
  // viewer2->addPointCloudNormals<pcl::PointXYZ, pcl::Normal> (cloud_cylinder1,cloud_normals2, 10, 0.2, "normals2");
     viewer0->setBackgroundColor (0, 0, 0);
 viewer1->setBackgroundColor (0, 0, 0);
 viewer2->setBackgroundColor (0, 0, 0);
  viewer3->setBackgroundColor (0, 0, 0);
   viewer4->setBackgroundColor (0, 0, 0);
   viewer5->setBackgroundColor (0, 0, 0);
   viewer6->setBackgroundColor (0, 0, 0);

 


   
    viewer0->addCoordinateSystem (1.0);
    viewer1->addCoordinateSystem (1.0);
    viewer2->addCoordinateSystem (1.0);
    viewer3->addCoordinateSystem (1.0);
    viewer4->addCoordinateSystem (1.0);
    viewer5->addCoordinateSystem (1.0);
    viewer6->addCoordinateSystem (1.0);

    viewer0->initCameraParameters ();
    viewer1->initCameraParameters ();
    viewer2->initCameraParameters (); 
     viewer3->initCameraParameters ();
     viewer4->initCameraParameters ();
     viewer5->initCameraParameters (); 
     viewer6->initCameraParameters (); 
    while (!viewer1->wasStopped())
    {   viewer0->spinOnce (100);
        viewer1->spinOnce (100);
        viewer2->spinOnce (100);
        viewer3->spinOnce (100);
        viewer4->spinOnce (100);
        viewer5->spinOnce (100);
        viewer6->spinOnce (100);
        boost::this_thread::sleep (boost::posix_time::microseconds (100000));
    }




}

int main(int argc, char **argv)  
{  
 
  printf("开始程序");
  cout<<endl;
	
  ros::init(argc,argv,"test");  
  ros::NodeHandle n;  
	pcl::PointCloud<pcl::PointXYZ>::Ptr cloud;
  ros::Subscriber sub = n.subscribe("velodyne_points", 10,velodyneViewerCallback);
	ros::spin();


  return (0);
 

}  





