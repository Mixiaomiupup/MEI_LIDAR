//雷达

#include <iostream>
#include <fstream>
#include <unistd.h>
#include <pthread.h>
#include <cmath>
#include <thread>
#include <ros/ros.h> 
#include <chrono>
#include <unistd.h>
#include <pthread.h>
#include <vector>
#include <sensor_msgs/LaserScan.h>

#include "serial.h"
#include "kalman.h"
#include "test.h"

#include "pcl_conversions/pcl_conversions.h"
#include <pcl/visualization/pcl_visualizer.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/filters/passthrough.h>
#include <pcl/ModelCoefficients.h>
#include <pcl/point_types.h>
#include <pcl/sample_consensus/method_types.h>
#include <pcl/sample_consensus/model_types.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/io/pcd_io.h>
#include <pcl/features/normal_3d.h>
#include <fstream>
#include <pcl/filters/project_inliers.h>


#include <pcl/filters/radius_outlier_removal.h>
#include <pcl/filters/conditional_removal.h>
#include <pcl/filters/statistical_outlier_removal.h>

using namespace std;
using namespace std::literals::chrono_literals;
double distance(double a1,double b1,double a2,double b2){
  return sqrt(pow(a1-b1,2) + pow(a2-b2,2));
}
typedef pcl::PointXYZ PointT;
void velodyneViewerCallback(const sensor_msgs::PointCloud2::ConstPtr &lidarMsg){
  int i=0;
  int j=0;
	// All the objects needed
  pcl::PCDReader reader;
  pcl::PassThrough<PointT> pass;
  pcl::NormalEstimation<PointT, pcl::Normal> ne;
  pcl::SACSegmentationFromNormals<PointT, pcl::Normal> seg; 
  pcl::PCDWriter writer;
  pcl::ExtractIndices<PointT> extract;
  pcl::ExtractIndices<pcl::Normal> extract_normals;
  pcl::search::KdTree<PointT>::Ptr tree (new pcl::search::KdTree<PointT> ());

  // Datasets
  pcl::PointCloud<PointT>::Ptr cloud (new pcl::PointCloud<PointT>);
  pcl::PointCloud<PointT>::Ptr cloud0 (new pcl::PointCloud<PointT>);
  pcl::PointCloud<PointT>::Ptr cloud1 (new pcl::PointCloud<PointT>);
   pcl::PointCloud<PointT>::Ptr cloud2 (new pcl::PointCloud<PointT>);
   
  pcl::PointCloud<PointT>::Ptr cloud_filtered0 (new pcl::PointCloud<PointT>);
  pcl::PointCloud<PointT>::Ptr cloud_filtered1 (new pcl::PointCloud<PointT>);
  pcl::PointCloud<PointT>::Ptr cloud_filtered2 (new pcl::PointCloud<PointT>);
 pcl::PointCloud<PointT>::Ptr cloud_filtered3 (new pcl::PointCloud<PointT>);   
  pcl::PointCloud<PointT>::Ptr cloud_filtered4 (new pcl::PointCloud<PointT>);
 pcl::PointCloud<PointT>::Ptr cloud_filtered5 (new pcl::PointCloud<PointT>);
  vector<pcl::PointCloud<PointT>::Ptr>  cloud_filtered;
   cloud_filtered.push_back(cloud_filtered0);
 cloud_filtered.push_back(cloud_filtered1);
 cloud_filtered.push_back(cloud_filtered2);
 cloud_filtered.push_back(cloud_filtered3);
 cloud_filtered.push_back(cloud_filtered4);
 cloud_filtered.push_back(cloud_filtered5);
  pcl::PointCloud<pcl::Normal>::Ptr cloud_normals0 (new pcl::PointCloud<pcl::Normal>);
  pcl::PointCloud<pcl::Normal>::Ptr cloud_normals1 (new pcl::PointCloud<pcl::Normal>);
  pcl::PointCloud<pcl::Normal>::Ptr cloud_normals2 (new pcl::PointCloud<pcl::Normal>);
 pcl::PointCloud<pcl::Normal>::Ptr cloud_normals3 (new pcl::PointCloud<pcl::Normal>);
  pcl::PointCloud<pcl::Normal>::Ptr cloud_normals4 (new pcl::PointCloud<pcl::Normal>);
  pcl::PointCloud<pcl::Normal>::Ptr cloud_normals5 (new pcl::PointCloud<pcl::Normal>);
  vector<pcl::PointCloud<pcl::Normal>::Ptr> cloud_normals;
  cloud_normals.push_back(cloud_normals0 );
cloud_normals.push_back(cloud_normals1);
cloud_normals.push_back(cloud_normals2 );
cloud_normals.push_back(cloud_normals3);
cloud_normals.push_back(cloud_normals4 );
cloud_normals.push_back(cloud_normals5 );
  pcl::ModelCoefficients::Ptr coefficients_cylinder0 (new pcl::ModelCoefficients),coefficients_cylinder1 (new pcl::ModelCoefficients),coefficients_cylinder2 (new pcl::ModelCoefficients),coefficients_cylinder3 (new pcl::ModelCoefficients),coefficients_cylinder4 (new pcl::ModelCoefficients);
  pcl::PointIndices::Ptr inliers_plane (new pcl::PointIndices), inliers_cylinder0 (new pcl::PointIndices),inliers_cylinder1 (new pcl::PointIndices),inliers_cylinder2 (new pcl::PointIndices),inliers_cylinder3 (new pcl::PointIndices),inliers_cylinder4 (new pcl::PointIndices);
 
 
  vector<pcl::ModelCoefficients::Ptr> coefficients_cylinder;
    // for(int i=0;i<5;i++){
  coefficients_cylinder.push_back(coefficients_cylinder0);
    coefficients_cylinder.push_back(coefficients_cylinder1);
      coefficients_cylinder.push_back(coefficients_cylinder2);
      coefficients_cylinder.push_back(coefficients_cylinder3);
      coefficients_cylinder.push_back(coefficients_cylinder4);
  // }
  vector<pcl::PointIndices::Ptr> inliers_cylinder;
    // for(int i=0;i<5;i++){
  inliers_cylinder.push_back(inliers_cylinder0);
  inliers_cylinder.push_back(inliers_cylinder1);
  inliers_cylinder.push_back(inliers_cylinder2);
   inliers_cylinder.push_back(inliers_cylinder3);
  inliers_cylinder.push_back(inliers_cylinder4);
  // }
   
   
   pcl::PointCloud<PointT>::Ptr cloud_cylinder0 (new pcl::PointCloud<PointT> ());
  pcl::PointCloud<PointT>::Ptr cloud_cylinder1 (new pcl::PointCloud<PointT> ());
  pcl::PointCloud<PointT>::Ptr cloud_cylinder2 (new pcl::PointCloud<PointT> ());
    pcl::PointCloud<PointT>::Ptr cloud_cylinder3 (new pcl::PointCloud<PointT> ());
  pcl::PointCloud<PointT>::Ptr cloud_cylinder4 (new pcl::PointCloud<PointT> ());
  cloud_cylinder0->points.clear();
  cloud_cylinder1->points.clear();
  cloud_cylinder2->points.clear();
  cloud_cylinder3->points.clear();
  cloud_cylinder4->points.clear();
  vector<pcl::PointCloud<PointT>::Ptr> cloud_cylinder;
    // for(int i=0;i<5;i++){
  cloud_cylinder.push_back(cloud_cylinder0);
  cloud_cylinder.push_back(cloud_cylinder1);
  cloud_cylinder.push_back(cloud_cylinder2);
    cloud_cylinder.push_back(cloud_cylinder3);
  cloud_cylinder.push_back(cloud_cylinder4);
  // }
//切割坐标轴
  fromROSMsg(*lidarMsg,*cloud);
  pass.setInputCloud (cloud);
  pass.setFilterFieldName ("y");
  pass.setFilterLimits (-4,0);
  pass.filter (*cloud0);
  
  pass.setInputCloud (cloud0);
  pass.setFilterFieldName ("x");
  pass.setFilterLimits (-4.0,4.0);
  pass.filter (*cloud1);

  pass.setInputCloud (cloud1);
  pass.setFilterFieldName ("z");
  pass.setFilterLimits (0,1.5);
  pass.filter (*cloud_filtered[0]);


//writer.write ("my_post.pcd", *cloud, false);
  // Estimate point normals
  ne.setSearchMethod (tree);
  ne.setInputCloud (cloud_filtered[0]);
  ne.setKSearch (100);
  ne.compute (*cloud_normals[0]);


double sum_x[5]={0,0,0,0,0};
double sum_y[5]={0,0,0,0,0};
double x[5]={100000,100000,100000,100000,100000};
double  y[5]={0,0,0,0,0};

for( i=0 ; i <= 3 ;i++){
  // cout<<i<<endl;
   seg.setOptimizeCoefficients (true);
   seg.setModelType (pcl::SACMODEL_CYLINDER);
   seg.setMethodType (pcl::SAC_RANSAC);
   seg.setNormalDistanceWeight (0.01);//越小对远处的圆柱拟合越好,0.05容易把一个柱子切两次
   seg.setMaxIterations (10000);
   seg.setDistanceThreshold (0.1);//0.1基本不需要动
   seg.setRadiusLimits (-0.07, 0.07);
   //cout<<"点云"<<cloud_filtered[i]->points.size()<<endl;
 //  cout<<"切线"<<cloud_normals[i]->points.size()<<endl;
   seg.setInputCloud (cloud_filtered[i]);//去除第０到第i-1个圆柱的点云

   seg.setInputNormals (cloud_normals[i]);//去除第０到第i-１个圆柱切线的切线集

   // Obtain the cylinder inliers and coefficients
   seg.segment (*inliers_cylinder[i], *coefficients_cylinder[i]);
  // cout<<"1"<<endl;
   //std::cerr << "Cylinder1 coefficients: " << *coefficients_cylinder1 << std::endl;

  extract.setInputCloud (cloud_filtered[i]);
  extract.setIndices (inliers_cylinder[i]);
  extract.setNegative (false);
 
  extract.filter (*cloud_cylinder[i]);
 //cout<<"cloud_cylinder["<<i<<"]:"<<cloud_cylinder[i]->points.size()<<endl;
if(cloud_cylinder[i]->points.size()==0){//一旦此次找不到，剩下的再也找不到了
  
        //cout<<"没有了"<<endl; 找不到的概率挺大的。。。。。
        break;
}

//Remove the cylinder0 inliers, extract the rest
  extract.setNegative (true);
  
  extract.filter (*cloud_filtered[i+1]);//滤掉圆柱１的点云 
//cout<<"cloud_filtered["<<i<<"]:"<<cloud_filtered[i]->points.size()<<endl;
  extract_normals.setNegative (true);
  extract_normals.setInputCloud (cloud_normals[i]);
  extract_normals.setIndices (inliers_cylinder[i]);

  extract_normals.filter (*cloud_normals[i+1]);//滤掉平面和圆柱１的切线的切线
  //cout<<"cloud_normals["<<i<<"]:"<<cloud_normals[i]->points.size()<<endl;

 

  for(int  it = 0;it < cloud_cylinder[i]->points.size();++it){
	  	sum_x[i] += (double)cloud_cylinder[i]->points[it].x*1000;
	  	sum_y[i] += (double)cloud_cylinder[i]->points[it].y*1000;


   }

   x[i]= sum_x[i]/cloud_cylinder[i]->points.size();
   y[i]=sum_y[i]/cloud_cylinder[i]->points.size();

   // std::cerr << "Cylinder  "<<i<<" x: " << x[i]<<" y : "<<y[i]<< std::endl;


  
}

// if(cloud_cylinder[3]->points.size()!=0){//测帧率
//    std::cerr << "Cylinder  "<<3<<" x: " << x[3]<<" y : "<<y[3]<< std::endl;
// }
int k=i;//记录拟合了几个圆柱
//cout<<"k="<<k<<endl;
if(k == 4){//拟合了四个及以上圆柱
  for( i=1 ; i<k ; i++ ){
     if(distance(x[i],x[i-1],y[i],y[i-1])<=30){//将被切开的圆柱合并回一个
    // cout<<"合并"<<i-1<<"和"<<i<<endl;
     x[i-1]=(sum_x[i-1]+sum_x[i])/(cloud_cylinder[i-1]->points.size()+cloud_cylinder[i]->points.size());
     y[i-1]=(sum_y[i-1]+sum_y[i])/(cloud_cylinder[i-1]->points.size()+cloud_cylinder[i]->points.size());
     x[i]=100000;
     y[i]=0;
   }
 }

  double tmpx,tmpy;//按x从小到大排序
  for( i = 1 ; i <= 3 ; i++ ){
    j = i-1;
    tmpx = x[i];
    tmpy = y[i];
   while( j >= 0 && x[j] > tmpx ){
       x[j+1] = x[j];
       y[j+1] = y[j];
       j--;
   }
      x[j+1] = tmpx;
      y[j+1] = tmpy;
   }
   for( i = 0 ; i <= 3; i++){//只留四个全部找到，四个找到三个其中一个被切两半的情况，其他情况全部排除

     if(x[i]>10000){
        cout<<"xs: "<<0<<" ys: "<<0<<endl;
        return;
    }
  }
  //  for( i = 0 ; i <= 3 ; i++ ){

  //   cout<<i<<" x "<<x[i]<<" y "<<y[i]<<endl;

  // }
  double sin,cos;
  double XS,YS,XR,YR;
  if(y[1] < y[0] && y[1] < y[2]&& y[3] <y[0] && y[3] < y[2] ){
      sin=(y[0]-y[2])/sqrt(pow(x[0]-x[2],2)+pow(y[0]-y[2],2));//雷达坐标系相对世界坐标系的旋转角度的三角函数
      cos=(x[2]-x[0])/sqrt(pow(x[0]-x[2],2)+pow(y[0]-y[2],2));
      XR=3090;//世界坐标系中柱子的坐标
      YR=0;

  XS=XR-x[0]*cos+y[0]*sin;
  YS=YR-x[0]*sin-y[0]*cos;
  cout<<"xs: "<<XS<<" ys: "<<YS<<endl;
  }
   if(y[0] < y[1] && y[0] < y[3]&& y[2] <y[1] && y[2] < y[3] ){

  sin=(y[1]-y[3])/sqrt(pow(x[1]-x[3],2)+pow(y[1]-y[3],2));//雷达坐标系相对世界坐标系的旋转角度的三角函数
  cos=(x[3]-x[1])/sqrt(pow(x[1]-x[3],2)+pow(y[1]-y[3],2));
  XR=5750;//世界坐标系中柱子的坐标
  YR=0;

  XS=XR-x[1]*cos+y[1]*sin;
  YS=YR-x[1]*sin-y[1]*cos;
  cout<<"xs: "<<XS<<" ys: "<<YS<<endl;
}

}
else{
  cout<<"xs: " <<0<<" ys: "<<0<<endl;
}


// for( i = 0 ; i <= 3 ; i++ ){

// cout<<i<<" x "<<x[i]<<" y "<<y[i]<<endl;

// }
// double distance01 = sqrt(pow(x[0]-x[1],2) + pow(y[0]-y[1],2));
// double distance12 = sqrt(pow(x[1]-x[2],2) + pow(y[1]-y[2],2));
// double distance02 = sqrt(pow(x[0]-x[2],2) + pow(y[0]-y[2],2));
// cout<<distance01<<" "<<distance12<<" "<<distance02<<endl;
// //cout<<" X0 "<<X0<<" Y0 "<<Y0<<" "<<sqrt(pow(X0,2)+pow(Y0,2))<<endl;
// //cout<<" X1 "<<X1<<" Y1 "<<Y1<<" "<<sqrt(pow(X1,2)+pow(Y1,2))<<endl;
// double sin,cos;
// sin=(Y0-Y1)/sqrt(pow(X1-X0,2)+pow(Y1-Y0,2));//雷达坐标系相对世界坐标系的旋转角度的三角函数
// cos=(X1-X0)/sqrt(pow(X1-X0,2)+pow(Y1-Y-
// 0,2));
// XR=3090;//世界坐标系中柱子的坐标
// YR=0;

// XS=XR-X0*cos+Y0*sin;
// YS=YR-X0*sin-Y0*cos;
//  cout<<"角度"<<asin(sin)*180/3.14159<<endl;

//   std::cerr << "XS " << XS <<" YS "<<YS<< std::endl;
  //    PointT basic_point;
  //    basic_point.x=YS;
  //  basic_point.y=XS;
  //  basic_point.z=3;
  // cloud_filtered[0]->points.push_back(basic_point);


//  boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer0 (new pcl::visualization::PCLVisualizer ("3D Viewer0"));
//  boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer1 (new pcl::visualization::PCLVisualizer ("3D Viewer1"));
//  boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer2 (new pcl::visualization::PCLVisualizer ("3D Viewer2"));
//    boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer3 (new pcl::visualization::PCLVisualizer ("3D Viewer3"));
//   boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer4 (new pcl::visualization::PCLVisualizer ("3D Viewer4"));
//   boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer5 (new pcl::visualization::PCLVisualizer ("3D Viewer5"));
//  viewer0->setBackgroundColor (0, 0, 0);
//  viewer1->setBackgroundColor (0, 0, 0);
//  viewer2->setBackgroundColor (0, 0, 0);
//   viewer3->setBackgroundColor (0, 0, 0);
//    viewer4->setBackgroundColor (0, 0, 0);
//    viewer5->setBackgroundColor (0, 0, 0);

//   viewer0->addPointCloud<pcl::PointXYZ> (cloud, "sample cloud0");
//   viewer1->addPointCloud<pcl::PointXYZ> (cloud_filtered[0], "sample cloud1");
//   viewer2->addPointCloud<pcl::PointXYZ> (cloud_cylinder[0], "sample cloud2");
//   viewer3->addPointCloud<pcl::PointXYZ> (cloud_cylinder[1], "sample cloud3");
//    viewer4->addPointCloud<pcl::PointXYZ> (cloud_cylinder[2], "sample cloud4");
//      viewer5->addPointCloud<pcl::PointXYZ> (cloud_cylinder[3], "sample cloud5");
//   // viewer0->addPointCloudNormals<pcl::PointXYZ, pcl::Normal> (cloud2,cloud_normals0, 10, 0.2, "normals0");
//   // viewer1->addPointCloudNormals<pcl::PointXYZ, pcl::Normal> (cloud_cylinder0,cloud_normals1, 10, 0.2, "normals1");
//   // viewer2->addPointCloudNormals<pcl::PointXYZ, pcl::Normal> (cloud_cylinder1,cloud_normals2, 10, 0.2, "normals2");


//     viewer0->setPointCloudRenderingProperties (pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 3, "sample cloud0");
//     viewer1->setPointCloudRenderingProperties (pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 3, "sample cloud1");
//     viewer2->setPointCloudRenderingProperties (pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 3, "sample cloud2");
//     viewer3->setPointCloudRenderingProperties (pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 3, "sample cloud3");
//      viewer4->setPointCloudRenderingProperties (pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 3, "sample cloud4");
//      viewer5->setPointCloudRenderingProperties (pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 3, "sample cloud5");
   
//     viewer0->addCoordinateSystem (1.0);
//     viewer1->addCoordinateSystem (1.0);
//     viewer2->addCoordinateSystem (1.0);
//     viewer3->addCoordinateSystem (1.0);
//      viewer4->addCoordinateSystem (1.0);
//      viewer5->addCoordinateSystem (1.0);


//     viewer0->initCameraParameters ();
//     viewer1->initCameraParameters ();
//     viewer2->initCameraParameters (); 
//      viewer3->initCameraParameters ();
//      viewer4->initCameraParameters ();
//      viewer5->initCameraParameters (); 
//     while (!viewer1->wasStopped())
//     {   viewer0->spinOnce (100);
//         viewer1->spinOnce (100);
//         viewer2->spinOnce (100);
//          viewer3->spinOnce (100);
//          viewer4->spinOnce (100);
//          viewer5->spinOnce (100);
//         boost::this_thread::sleep (boost::posix_time::microseconds (100000));
//     }




}

int main(int argc, char **argv)  
{  
  
  printf("开始程序");
  cout<<endl;
	fstream f1("data0.txt",ios::out|ios::trunc);
  ros::init(argc,argv,"test");  
  ros::NodeHandle n;  
	pcl::PointCloud<pcl::PointXYZ>::Ptr cloud;
  ros::Subscriber sub = n.subscribe("velodyne_points", 10,velodyneViewerCallback);
	ros::spin();


  return (0);
 

}  





